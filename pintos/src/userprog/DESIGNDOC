        +--------------------------+
             |          CS 140          |
             | PROJECT 2: USER PROGRAMS |
             |     DESIGN DOCUMENT      |
             +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Ethan Duong duonget@uci.edu
Grant Kinsley gkinsley@uci.edu

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

               ARGUMENT PASSING
               ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

We did not add new variables or make changes to any structs, but we changed function declarations of 
process_execute, load, start_process, and setup_stack so that these functions could more easily pass pointers to 
arguments between each other.

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

We need to load our arguments onto the stack in the order according to the spec: https://www.ics.uci.edu/~ardalan/
courses/os/pintos/pintos_4.html#SEC61. To do this, we parse our arguments using strtok_r allowing us to grab each 
argument and store them as c-strings. We copy said arguments in reverse order and store them in an array. We then 
push the array of pointers onto the stack followed by the argument count and then a fake return address. In order 
to prevent us from overflowing the stack page, we limit the number of arguments.



---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

Pintos implements strtok_r instead of strtok because strtok uses the previous token of the string to retrieve the 
next token in the next call to strtok. This introduces a race condition if two threads call strtok, since one 
thread may use the last token that was meant for the other thread. This would be an incorrect implementation and is 
solved by using strtok_r which doesn’t rely on the same mechanism as strtok.

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

An advantage of the Unix approach is that the kernel doesn’t have to deal with parsing and results in improved 
concurrency, which means the kernel can be used for other operations requested by other user level threads. This 
leads to another advantage where overall performance of the system should improve, as kernel threads and kernel 
operations are more expensive to execute.

                 SYSTEM CALLS
                 ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

For each open file, there is a single set of file descriptors assigned to that file. File descriptors are also 
unique within the entire OS, since each process will have its own file descriptor counter.

---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.

Although we were not able to implement this functionality, the following strategy would be how we implement it:
First, check that the stack pointer is valid, and if so, we can use it to find the correct system call to run. From 
the stack pointer, we can check the arguments that will be used with the system call. Finally, we can check if the 
buffer is valid, and if so, we can just make our system call.

>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

Full Page: The best case scenario is when all 4,096 bytes of data are located on the same physical page. In this 
case, only one page (one call to pagedir_get_page()) needs to be pulled into the kernel. In the worst case, each 
byte is located on a different physical page (random access) meaning that we need up to 4,096 calls to 
pagedir_get_page() to get all the data into the kernel.

2 bytes: With the same reasoning as above, the best and worst results are 1 and 2 calls to pagedir_get_page() 
respectively.

We can improve these numbers by organizing our data and calls so that the data we want is on the same physical page 
(or at the very least not spread out over a ton of different pages). This ensures the least number of calls to 
pagedir_get_page() (best we can do is 1 call).

>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

We did not implement the wait system call.

>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.

We didn’t implement access to user memory.

---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

We didn’t implement access to user memory. However, if we did implement user memory and error checking, we would do 
so by verifying the validity of user-provided pointers when they access memory. The bounds of user memory (the 
virtual addresses) are predetermined so this check should be simple.

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

As certain file descriptors are only used by a single process, we don’t have to worry about multiple processes 
accessing the same file descriptors. Therefore, race conditions are impossible within the file descriptors.

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

We did not change the tid_t to pid_t mapping.

               SURVEY QUESTIONS
               ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?

